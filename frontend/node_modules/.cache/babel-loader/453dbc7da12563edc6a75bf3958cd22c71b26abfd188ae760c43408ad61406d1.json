{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useWebSocketStream Hook\n * Centralized WebSocket connection management with message routing and auto-reconnection\n */\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst WS_URL = 'ws://localhost:8000/ws/realtime';\nconst RECONNECT_INTERVAL = 3000; // 3 seconds\nconst MAX_RECONNECT_ATTEMPTS = 10;\nexport const useWebSocketStream = () => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n  const [error, setError] = useState(null);\n  const [wsData, setWsData] = useState({\n    parameters: null,\n    defectAlerts: [],\n    mlPredictions: [],\n    systemHealth: null,\n    defectAggregation: {},\n    recommendations: [],\n    qualityMetrics: null,\n    lastUpdate: null\n  });\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const mountedRef = useRef(true);\n  const connect = useCallback(() => {\n    if (!mountedRef.current) return;\n    try {\n      const ws = new WebSocket(WS_URL);\n      wsRef.current = ws;\n      ws.onopen = () => {\n        console.log('âœ… WebSocket connected');\n        setIsConnected(true);\n        setReconnectAttempts(0);\n        setError(null);\n      };\n      ws.onmessage = event => {\n        var _message$data, _message$data$furnace, _message$data2, _message$data3, _message$data3$action, _message$data4;\n        try {\n          const message = JSON.parse(event.data);\n          const timestamp = new Date().toISOString();\n\n          // Route message based on type\n          switch (message.type) {\n            case 'parameter_update':\n              setWsData(prev => ({\n                ...prev,\n                parameters: message.data,\n                lastUpdate: timestamp\n              }));\n              console.log('ðŸ“Š Parameters updated:', (_message$data = message.data) === null || _message$data === void 0 ? void 0 : (_message$data$furnace = _message$data.furnace) === null || _message$data$furnace === void 0 ? void 0 : _message$data$furnace.temperature);\n              break;\n            case 'defect_alert':\n              setWsData(prev => {\n                const newAlert = message.data;\n\n                // Update defect aggregation\n                const newAggregation = {\n                  ...prev.defectAggregation\n                };\n                const defectType = newAlert.defect_type;\n                newAggregation[defectType] = (newAggregation[defectType] || 0) + 1;\n\n                // Calculate total defects\n                const totalDefects = Object.values(newAggregation).reduce((sum, count) => sum + count, 0);\n\n                // Calculate quality rate (assume 1000 units base, subtract defects)\n                const baseUnits = 1000;\n                const qualityRate = Math.max(85, (baseUnits - totalDefects) / baseUnits * 100);\n                return {\n                  ...prev,\n                  defectAlerts: [...prev.defectAlerts.slice(-99), newAlert],\n                  defectAggregation: newAggregation,\n                  qualityMetrics: {\n                    qualityRate: Math.round(qualityRate * 10) / 10,\n                    defectCount: totalDefects,\n                    unitsProduced: baseUnits\n                  },\n                  lastUpdate: timestamp\n                };\n              });\n              console.log('ðŸ”´ Defect detected:', (_message$data2 = message.data) === null || _message$data2 === void 0 ? void 0 : _message$data2.defect_type);\n              break;\n            case 'ml_prediction':\n              setWsData(prev => ({\n                ...prev,\n                mlPredictions: [...prev.mlPredictions.slice(-49), message.data],\n                lastUpdate: timestamp\n              }));\n              break;\n            case 'system_health':\n              setWsData(prev => ({\n                ...prev,\n                systemHealth: message.data,\n                lastUpdate: timestamp\n              }));\n              break;\n            case 'recommendation':\n              setWsData(prev => ({\n                ...prev,\n                recommendations: [...prev.recommendations.slice(-19), message.data],\n                lastUpdate: timestamp\n              }));\n              console.log('ðŸ’¡ Recommendation received:', (_message$data3 = message.data) === null || _message$data3 === void 0 ? void 0 : (_message$data3$action = _message$data3.action) === null || _message$data3$action === void 0 ? void 0 : _message$data3$action.slice(0, 50));\n              break;\n            case 'quality_metrics':\n              // Update quality metrics from backend\n              if (message.data) {\n                setWsData(prev => {\n                  var _prev$qualityMetrics, _prev$qualityMetrics2, _prev$qualityMetrics3;\n                  return {\n                    ...prev,\n                    qualityMetrics: {\n                      qualityRate: message.data.current_quality_rate || message.data.quality_rate || ((_prev$qualityMetrics = prev.qualityMetrics) === null || _prev$qualityMetrics === void 0 ? void 0 : _prev$qualityMetrics.qualityRate) || 95,\n                      defectCount: message.data.defect_count_hourly || message.data.defect_count || ((_prev$qualityMetrics2 = prev.qualityMetrics) === null || _prev$qualityMetrics2 === void 0 ? void 0 : _prev$qualityMetrics2.defectCount) || 0,\n                      unitsProduced: message.data.units_produced || ((_prev$qualityMetrics3 = prev.qualityMetrics) === null || _prev$qualityMetrics3 === void 0 ? void 0 : _prev$qualityMetrics3.unitsProduced) || 1000\n                    },\n                    lastUpdate: timestamp\n                  };\n                });\n                console.log('ðŸ“ˆ Quality metrics updated:', message.data.current_quality_rate);\n              }\n              break;\n            case 'realtime_update':\n              // Handle combined realtime updates\n              if (message.data) {\n                setWsData(prev => {\n                  var _prev$qualityMetrics4, _prev$qualityMetrics5, _prev$qualityMetrics6;\n                  return {\n                    ...prev,\n                    qualityMetrics: {\n                      qualityRate: message.data.current_quality_rate || ((_prev$qualityMetrics4 = prev.qualityMetrics) === null || _prev$qualityMetrics4 === void 0 ? void 0 : _prev$qualityMetrics4.qualityRate) || 95,\n                      defectCount: message.data.defect_count_hourly || ((_prev$qualityMetrics5 = prev.qualityMetrics) === null || _prev$qualityMetrics5 === void 0 ? void 0 : _prev$qualityMetrics5.defectCount) || 0,\n                      unitsProduced: message.data.units_produced || ((_prev$qualityMetrics6 = prev.qualityMetrics) === null || _prev$qualityMetrics6 === void 0 ? void 0 : _prev$qualityMetrics6.unitsProduced) || 1000\n                    },\n                    lastUpdate: timestamp\n                  };\n                });\n              }\n              break;\n            case 'sensor_update':\n              // Raw sensor data - extract parameters if available\n              if ((_message$data4 = message.data) !== null && _message$data4 !== void 0 && _message$data4.state_summary) {\n                const state = message.data.state_summary;\n                setWsData(prev => {\n                  var _prev$parameters, _prev$parameters$furn, _prev$parameters2, _prev$parameters2$fur, _prev$parameters3, _prev$parameters3$for, _prev$parameters4, _prev$parameters4$for, _prev$parameters5, _prev$parameters5$for, _prev$parameters6, _prev$parameters6$ann, _prev$parameters7, _prev$parameters7$ann;\n                  return {\n                    ...prev,\n                    parameters: {\n                      furnace: {\n                        temperature: state.furnace_temperature || ((_prev$parameters = prev.parameters) === null || _prev$parameters === void 0 ? void 0 : (_prev$parameters$furn = _prev$parameters.furnace) === null || _prev$parameters$furn === void 0 ? void 0 : _prev$parameters$furn.temperature) || 1520,\n                        pressure: state.furnace_pressure || ((_prev$parameters2 = prev.parameters) === null || _prev$parameters2 === void 0 ? void 0 : (_prev$parameters2$fur = _prev$parameters2.furnace) === null || _prev$parameters2$fur === void 0 ? void 0 : _prev$parameters2$fur.pressure) || 25\n                      },\n                      forming: {\n                        speed: state.belt_speed || ((_prev$parameters3 = prev.parameters) === null || _prev$parameters3 === void 0 ? void 0 : (_prev$parameters3$for = _prev$parameters3.forming) === null || _prev$parameters3$for === void 0 ? void 0 : _prev$parameters3$for.speed) || 150,\n                        mold_temp: state.mold_temp || ((_prev$parameters4 = prev.parameters) === null || _prev$parameters4 === void 0 ? void 0 : (_prev$parameters4$for = _prev$parameters4.forming) === null || _prev$parameters4$for === void 0 ? void 0 : _prev$parameters4$for.mold_temp) || 320,\n                        pressure: state.forming_pressure || ((_prev$parameters5 = prev.parameters) === null || _prev$parameters5 === void 0 ? void 0 : (_prev$parameters5$for = _prev$parameters5.forming) === null || _prev$parameters5$for === void 0 ? void 0 : _prev$parameters5$for.pressure) || 45\n                      },\n                      annealing: {\n                        temperature: state.annealing_temp || ((_prev$parameters6 = prev.parameters) === null || _prev$parameters6 === void 0 ? void 0 : (_prev$parameters6$ann = _prev$parameters6.annealing) === null || _prev$parameters6$ann === void 0 ? void 0 : _prev$parameters6$ann.temperature) || 580,\n                        cooling_rate: state.cooling_rate || ((_prev$parameters7 = prev.parameters) === null || _prev$parameters7 === void 0 ? void 0 : (_prev$parameters7$ann = _prev$parameters7.annealing) === null || _prev$parameters7$ann === void 0 ? void 0 : _prev$parameters7$ann.cooling_rate) || 3.5\n                      },\n                      timestamp: timestamp\n                    },\n                    lastUpdate: timestamp\n                  };\n                });\n              }\n              break;\n            case 'welcome':\n            case 'heartbeat':\n            case 'pong':\n              // Connection management messages\n              console.log('ðŸ“¡', message.message || 'Heartbeat received');\n              break;\n            default:\n              console.log('Unknown message type:', message.type, message);\n          }\n        } catch (err) {\n          console.error('Error parsing WebSocket message:', err);\n        }\n      };\n      ws.onerror = event => {\n        console.error('âŒ WebSocket error:', event);\n        setError('WebSocket connection error');\n      };\n      ws.onclose = () => {\n        console.log('ðŸ”Œ WebSocket disconnected');\n        setIsConnected(false);\n        wsRef.current = null;\n\n        // Auto-reconnect with exponential backoff\n        if (mountedRef.current && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n          const delay = Math.min(RECONNECT_INTERVAL * Math.pow(1.5, reconnectAttempts), 30000);\n          console.log(`ðŸ”„ Reconnecting in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            setReconnectAttempts(prev => prev + 1);\n            connect();\n          }, delay);\n        } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n          setError('Maximum reconnection attempts reached');\n        }\n      };\n    } catch (err) {\n      console.error('Error creating WebSocket:', err);\n      setError('Failed to create WebSocket connection');\n    }\n  }, [reconnectAttempts]);\n  const sendMessage = useCallback(message => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('âš ï¸ WebSocket not connected, cannot send message');\n    }\n  }, []);\n  useEffect(() => {\n    mountedRef.current = true;\n    connect();\n\n    // Cleanup on unmount\n    return () => {\n      mountedRef.current = false;\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        wsRef.current.close();\n        wsRef.current = null;\n      }\n    };\n  }, [connect]);\n  return {\n    wsData,\n    isConnected,\n    reconnectAttempts,\n    error,\n    sendMessage\n  };\n};\n_s(useWebSocketStream, \"XApzsmI9bun0xx24TwdsxmrY4pM=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","WS_URL","RECONNECT_INTERVAL","MAX_RECONNECT_ATTEMPTS","useWebSocketStream","_s","isConnected","setIsConnected","reconnectAttempts","setReconnectAttempts","error","setError","wsData","setWsData","parameters","defectAlerts","mlPredictions","systemHealth","defectAggregation","recommendations","qualityMetrics","lastUpdate","wsRef","reconnectTimeoutRef","mountedRef","connect","current","ws","WebSocket","onopen","console","log","onmessage","event","_message$data","_message$data$furnace","_message$data2","_message$data3","_message$data3$action","_message$data4","message","JSON","parse","data","timestamp","Date","toISOString","type","prev","furnace","temperature","newAlert","newAggregation","defectType","defect_type","totalDefects","Object","values","reduce","sum","count","baseUnits","qualityRate","Math","max","slice","round","defectCount","unitsProduced","action","_prev$qualityMetrics","_prev$qualityMetrics2","_prev$qualityMetrics3","current_quality_rate","quality_rate","defect_count_hourly","defect_count","units_produced","_prev$qualityMetrics4","_prev$qualityMetrics5","_prev$qualityMetrics6","state_summary","state","_prev$parameters","_prev$parameters$furn","_prev$parameters2","_prev$parameters2$fur","_prev$parameters3","_prev$parameters3$for","_prev$parameters4","_prev$parameters4$for","_prev$parameters5","_prev$parameters5$for","_prev$parameters6","_prev$parameters6$ann","_prev$parameters7","_prev$parameters7$ann","furnace_temperature","pressure","furnace_pressure","forming","speed","belt_speed","mold_temp","forming_pressure","annealing","annealing_temp","cooling_rate","err","onerror","onclose","delay","min","pow","setTimeout","sendMessage","readyState","OPEN","send","stringify","warn","clearTimeout","close"],"sources":["C:/Users/hehehe/Desktop/scripts/glass_ai/frontend/src/hooks/useWebSocketStream.ts"],"sourcesContent":["/**\n * useWebSocketStream Hook\n * Centralized WebSocket connection management with message routing and auto-reconnection\n */\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nconst WS_URL = 'ws://localhost:8000/ws/realtime';\nconst RECONNECT_INTERVAL = 3000; // 3 seconds\nconst MAX_RECONNECT_ATTEMPTS = 10;\n\nexport interface ParameterUpdate {\n  furnace: {\n    temperature: number;\n    pressure: number;\n  };\n  forming: {\n    speed: number;\n    mold_temp: number;\n    pressure: number;\n  };\n  annealing: {\n    temperature: number;\n    cooling_rate: number;\n  };\n  timestamp: string;\n}\n\nexport interface DefectAlert {\n  defect_type: string;\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  probability: number;\n  location: {\n    line: string;\n    position_x: number;\n    position_y: number;\n  };\n  timestamp: string;\n  confidence: number;\n  parameters_snapshot: {\n    furnace_temperature: number;\n    belt_speed: number;\n  };\n}\n\nexport interface MLPrediction {\n  model: string;\n  predictions: any[];\n  confidence: number;\n  timestamp: string;\n}\n\nexport interface SystemHealth {\n  status: string;\n  uptime: string;\n  active_connections: number;\n  timestamp: string;\n}\n\nexport interface DefectAggregation {\n  [defectType: string]: number;\n}\n\nexport interface WebSocketData {\n  parameters: ParameterUpdate | null;\n  defectAlerts: DefectAlert[];\n  mlPredictions: MLPrediction[];\n  systemHealth: SystemHealth | null;\n  defectAggregation: DefectAggregation;\n  recommendations: any[];\n  qualityMetrics: {\n    qualityRate: number;\n    defectCount: number;\n    unitsProduced: number;\n  } | null;\n  lastUpdate: string | null;\n}\n\nexport interface UseWebSocketStreamReturn {\n  wsData: WebSocketData;\n  isConnected: boolean;\n  reconnectAttempts: number;\n  error: string | null;\n  sendMessage: (message: any) => void;\n}\n\nexport const useWebSocketStream = (): UseWebSocketStreamReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const [wsData, setWsData] = useState<WebSocketData>({\n    parameters: null,\n    defectAlerts: [],\n    mlPredictions: [],\n    systemHealth: null,\n    defectAggregation: {},\n    recommendations: [],\n    qualityMetrics: null,\n    lastUpdate: null\n  });\n\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const mountedRef = useRef(true);\n\n  const connect = useCallback(() => {\n    if (!mountedRef.current) return;\n\n    try {\n      const ws = new WebSocket(WS_URL);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        console.log('âœ… WebSocket connected');\n        setIsConnected(true);\n        setReconnectAttempts(0);\n        setError(null);\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          const timestamp = new Date().toISOString();\n          \n          // Route message based on type\n          switch (message.type) {\n            case 'parameter_update':\n              setWsData(prev => ({\n                ...prev,\n                parameters: message.data,\n                lastUpdate: timestamp\n              }));\n              console.log('ðŸ“Š Parameters updated:', message.data?.furnace?.temperature);\n              break;\n\n            case 'defect_alert':\n              setWsData(prev => {\n                const newAlert = message.data;\n                \n                // Update defect aggregation\n                const newAggregation = { ...prev.defectAggregation };\n                const defectType = newAlert.defect_type;\n                newAggregation[defectType] = (newAggregation[defectType] || 0) + 1;\n                \n                // Calculate total defects\n                const totalDefects = Object.values(newAggregation).reduce((sum, count) => sum + count, 0);\n                \n                // Calculate quality rate (assume 1000 units base, subtract defects)\n                const baseUnits = 1000;\n                const qualityRate = Math.max(85, ((baseUnits - totalDefects) / baseUnits) * 100);\n\n                return {\n                  ...prev,\n                  defectAlerts: [...prev.defectAlerts.slice(-99), newAlert],\n                  defectAggregation: newAggregation,\n                  qualityMetrics: {\n                    qualityRate: Math.round(qualityRate * 10) / 10,\n                    defectCount: totalDefects,\n                    unitsProduced: baseUnits\n                  },\n                  lastUpdate: timestamp\n                };\n              });\n              console.log('ðŸ”´ Defect detected:', message.data?.defect_type);\n              break;\n\n            case 'ml_prediction':\n              setWsData(prev => ({\n                ...prev,\n                mlPredictions: [...prev.mlPredictions.slice(-49), message.data],\n                lastUpdate: timestamp\n              }));\n              break;\n\n            case 'system_health':\n              setWsData(prev => ({\n                ...prev,\n                systemHealth: message.data,\n                lastUpdate: timestamp\n              }));\n              break;\n\n            case 'recommendation':\n              setWsData(prev => ({\n                ...prev,\n                recommendations: [...prev.recommendations.slice(-19), message.data],\n                lastUpdate: timestamp\n              }));\n              console.log('ðŸ’¡ Recommendation received:', message.data?.action?.slice(0, 50));\n              break;\n\n            case 'quality_metrics':\n              // Update quality metrics from backend\n              if (message.data) {\n                setWsData(prev => ({\n                  ...prev,\n                  qualityMetrics: {\n                    qualityRate: message.data.current_quality_rate || message.data.quality_rate || prev.qualityMetrics?.qualityRate || 95,\n                    defectCount: message.data.defect_count_hourly || message.data.defect_count || prev.qualityMetrics?.defectCount || 0,\n                    unitsProduced: message.data.units_produced || prev.qualityMetrics?.unitsProduced || 1000\n                  },\n                  lastUpdate: timestamp\n                }));\n                console.log('ðŸ“ˆ Quality metrics updated:', message.data.current_quality_rate);\n              }\n              break;\n\n            case 'realtime_update':\n              // Handle combined realtime updates\n              if (message.data) {\n                setWsData(prev => ({\n                  ...prev,\n                  qualityMetrics: {\n                    qualityRate: message.data.current_quality_rate || prev.qualityMetrics?.qualityRate || 95,\n                    defectCount: message.data.defect_count_hourly || prev.qualityMetrics?.defectCount || 0,\n                    unitsProduced: message.data.units_produced || prev.qualityMetrics?.unitsProduced || 1000\n                  },\n                  lastUpdate: timestamp\n                }));\n              }\n              break;\n\n            case 'sensor_update':\n              // Raw sensor data - extract parameters if available\n              if (message.data?.state_summary) {\n                const state = message.data.state_summary;\n                setWsData(prev => ({\n                  ...prev,\n                  parameters: {\n                    furnace: {\n                      temperature: state.furnace_temperature || prev.parameters?.furnace?.temperature || 1520,\n                      pressure: state.furnace_pressure || prev.parameters?.furnace?.pressure || 25\n                    },\n                    forming: {\n                      speed: state.belt_speed || prev.parameters?.forming?.speed || 150,\n                      mold_temp: state.mold_temp || prev.parameters?.forming?.mold_temp || 320,\n                      pressure: state.forming_pressure || prev.parameters?.forming?.pressure || 45\n                    },\n                    annealing: {\n                      temperature: state.annealing_temp || prev.parameters?.annealing?.temperature || 580,\n                      cooling_rate: state.cooling_rate || prev.parameters?.annealing?.cooling_rate || 3.5\n                    },\n                    timestamp: timestamp\n                  },\n                  lastUpdate: timestamp\n                }));\n              }\n              break;\n\n            case 'welcome':\n            case 'heartbeat':\n            case 'pong':\n              // Connection management messages\n              console.log('ðŸ“¡', message.message || 'Heartbeat received');\n              break;\n\n            default:\n              console.log('Unknown message type:', message.type, message);\n          }\n        } catch (err) {\n          console.error('Error parsing WebSocket message:', err);\n        }\n      };\n\n      ws.onerror = (event) => {\n        console.error('âŒ WebSocket error:', event);\n        setError('WebSocket connection error');\n      };\n\n      ws.onclose = () => {\n        console.log('ðŸ”Œ WebSocket disconnected');\n        setIsConnected(false);\n        wsRef.current = null;\n\n        // Auto-reconnect with exponential backoff\n        if (mountedRef.current && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n          const delay = Math.min(RECONNECT_INTERVAL * Math.pow(1.5, reconnectAttempts), 30000);\n          console.log(`ðŸ”„ Reconnecting in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            setReconnectAttempts(prev => prev + 1);\n            connect();\n          }, delay);\n        } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n          setError('Maximum reconnection attempts reached');\n        }\n      };\n    } catch (err) {\n      console.error('Error creating WebSocket:', err);\n      setError('Failed to create WebSocket connection');\n    }\n  }, [reconnectAttempts]);\n\n  const sendMessage = useCallback((message: any) => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('âš ï¸ WebSocket not connected, cannot send message');\n    }\n  }, []);\n\n  useEffect(() => {\n    mountedRef.current = true;\n    connect();\n\n    // Cleanup on unmount\n    return () => {\n      mountedRef.current = false;\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        wsRef.current.close();\n        wsRef.current = null;\n      }\n    };\n  }, [connect]);\n\n  return {\n    wsData,\n    isConnected,\n    reconnectAttempts,\n    error,\n    sendMessage\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}