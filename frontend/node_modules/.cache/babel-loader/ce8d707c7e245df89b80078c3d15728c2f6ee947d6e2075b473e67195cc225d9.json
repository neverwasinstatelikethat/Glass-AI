{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst DEFECT_COLORS = {\n  crack: '#FF1744',\n  bubble: '#FFD700',\n  chip: '#00E676',\n  stain: '#9D4EDD',\n  cloudiness: '#00E5FF',\n  deformation: '#FF3366'\n};\nconst DEFECT_NAMES = {\n  crack: 'Трещины',\n  bubble: 'Пузыри',\n  chip: 'Сколы',\n  stain: 'Пятна',\n  cloudiness: 'Помутнение',\n  deformation: 'Деформация'\n};\nconst useDashboardData = () => {\n  _s();\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const fetchCountRef = useRef(0);\n  const performanceHistoryRef = useRef([]);\n  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n  // Fetch all dashboard data from backend APIs\n  const fetchData = useCallback(async () => {\n    try {\n      var _sensorParams$furnace, _sensorParams$furnace2, _sensorParams$forming, _sensorParams$forming2;\n      fetchCountRef.current += 1;\n      const isFirstFetch = fetchCountRef.current === 1;\n      if (isFirstFetch) setLoading(true);\n\n      // Parallel fetch all endpoints\n      const [qualityRes, alertsRes, trendsRes, efficiencyRes, rlRecsRes, statsRes, dtStateRes] = await Promise.allSettled([fetch(`${API_BASE_URL}/api/quality/metrics`), fetch(`${API_BASE_URL}/api/alerts/active`), fetch(`${API_BASE_URL}/api/analytics/defect-trends?timerange=24h&grouping=hourly`), fetch(`${API_BASE_URL}/api/analytics/production-efficiency?timerange=24h`), fetch(`${API_BASE_URL}/api/rl/recommendations/detailed`), fetch(`${API_BASE_URL}/api/statistics`), fetch(`${API_BASE_URL}/api/digital-twin/state`)]);\n\n      // Parse quality metrics\n      let qualityData = {};\n      if (qualityRes.status === 'fulfilled' && qualityRes.value.ok) {\n        qualityData = await qualityRes.value.json();\n      }\n\n      // Parse statistics for uptime\n      let statsData = {};\n      if (statsRes.status === 'fulfilled' && statsRes.value.ok) {\n        statsData = await statsRes.value.json();\n      }\n\n      // Parse digital twin state for real-time sensor values\n      let dtState = {};\n      if (dtStateRes.status === 'fulfilled' && dtStateRes.value.ok) {\n        const dtResponse = await dtStateRes.value.json();\n        dtState = dtResponse.data || dtResponse;\n      }\n\n      // Parse defect trends for distribution\n      let trendsData = {\n        data_points: []\n      };\n      if (trendsRes.status === 'fulfilled' && trendsRes.value.ok) {\n        trendsData = await trendsRes.value.json();\n      }\n\n      // Parse efficiency data for performance chart\n      let efficiencyData = {\n        data_points: []\n      };\n      if (efficiencyRes.status === 'fulfilled' && efficiencyRes.value.ok) {\n        efficiencyData = await efficiencyRes.value.json();\n      }\n\n      // Parse RL recommendations\n      let recommendationsData = [];\n      if (rlRecsRes.status === 'fulfilled' && rlRecsRes.value.ok) {\n        const rlData = await rlRecsRes.value.json();\n        recommendationsData = rlData.recommendations || rlData || [];\n      }\n\n      // Fallback to regular recommendations\n      if (!recommendationsData || recommendationsData.length === 0) {\n        try {\n          const fallbackRes = await fetch(`${API_BASE_URL}/api/recommendations`);\n          if (fallbackRes.ok) {\n            recommendationsData = await fallbackRes.json();\n          }\n        } catch (e) {\n          console.warn('Fallback recommendations failed:', e);\n        }\n      }\n\n      // Build defect distribution from trends data\n      const defectDistribution = [];\n      const defectTypes = ['crack', 'bubble', 'chip', 'stain', 'cloudiness', 'deformation'];\n      if (trendsData.data_points && trendsData.data_points.length > 0) {\n        // Aggregate defects from all data points\n        const aggregated = {};\n        defectTypes.forEach(dt => aggregated[dt] = 0);\n        trendsData.data_points.forEach(dp => {\n          defectTypes.forEach(dt => {\n            aggregated[dt] += dp[dt] || 0;\n          });\n        });\n        defectTypes.forEach(dt => {\n          if (aggregated[dt] > 0) {\n            defectDistribution.push({\n              name: DEFECT_NAMES[dt] || dt,\n              value: aggregated[dt],\n              color: DEFECT_COLORS[dt] || '#888888'\n            });\n          }\n        });\n      }\n\n      // Fallback if no data\n      if (defectDistribution.length === 0) {\n        defectDistribution.push({\n          name: 'Трещины',\n          value: 0,\n          color: '#FF1744'\n        }, {\n          name: 'Пузыри',\n          value: 0,\n          color: '#FFD700'\n        }, {\n          name: 'Сколы',\n          value: 0,\n          color: '#00E676'\n        });\n      }\n\n      // Build performance data from efficiency or trends\n      let performanceData = [];\n      if (efficiencyData.data_points && efficiencyData.data_points.length > 0) {\n        performanceData = efficiencyData.data_points.map(dp => {\n          const ts = new Date(dp.timestamp);\n          return {\n            time: ts.toLocaleTimeString('ru-RU', {\n              hour: '2-digit',\n              minute: '2-digit'\n            }),\n            quality: dp.quality_rate || dp.quality || 95,\n            defects: dp.defect_count || Math.round((100 - (dp.quality_rate || 95)) * 10)\n          };\n        }).slice(-12); // Last 12 points\n      } else if (trendsData.data_points && trendsData.data_points.length > 0) {\n        performanceData = trendsData.data_points.map(dp => {\n          const ts = new Date(dp.timestamp);\n          return {\n            time: ts.toLocaleTimeString('ru-RU', {\n              hour: '2-digit',\n              minute: '2-digit'\n            }),\n            quality: 100 - (dp.total_defects || 0) * 0.5,\n            defects: dp.total_defects || 0\n          };\n        }).slice(-12);\n      }\n\n      // Store in history and merge\n      if (performanceData.length > 0) {\n        performanceHistoryRef.current = performanceData;\n      } else {\n        performanceData = performanceHistoryRef.current;\n      }\n\n      // Build real-time metrics from digital twin state\n      const sensorParams = dtState.parameters || dtState.sensor_values || {};\n      const realTimeMetrics = [{\n        name: 'Температура печи',\n        value: Math.round(sensorParams.furnace_temperature || ((_sensorParams$furnace = sensorParams.furnace) === null || _sensorParams$furnace === void 0 ? void 0 : _sensorParams$furnace.temperature) || 1520),\n        unit: '°C',\n        max: 1600,\n        trend: 'stable',\n        icon: 'LocalFireDepartment'\n      }, {\n        name: 'Давление печи',\n        value: Math.round((sensorParams.furnace_pressure || ((_sensorParams$furnace2 = sensorParams.furnace) === null || _sensorParams$furnace2 === void 0 ? void 0 : _sensorParams$furnace2.pressure) || 25) * 10) / 10,\n        unit: 'кПа',\n        max: 50,\n        trend: 'stable',\n        icon: 'WaterDrop'\n      }, {\n        name: 'Скорость ленты',\n        value: Math.round(sensorParams.belt_speed || ((_sensorParams$forming = sensorParams.forming) === null || _sensorParams$forming === void 0 ? void 0 : _sensorParams$forming.speed) || 155),\n        unit: 'м/мин',\n        max: 200,\n        trend: 'stable',\n        icon: 'Speed'\n      }, {\n        name: 'Температура формы',\n        value: Math.round(sensorParams.mold_temp || ((_sensorParams$forming2 = sensorParams.forming) === null || _sensorParams$forming2 === void 0 ? void 0 : _sensorParams$forming2.mold_temp) || 320),\n        unit: '°C',\n        max: 400,\n        trend: 'stable',\n        icon: 'Thermostat'\n      }];\n\n      // Build AI recommendations from RL data\n      const aiRecommendations = Array.isArray(recommendationsData) && recommendationsData.length > 0 ? recommendationsData.map(rec => ({\n        text: rec.text || rec.description || rec.action || 'Рекомендация RL агента',\n        priority: (rec.priority || rec.urgency || 'medium').toLowerCase(),\n        impact: rec.impact || Math.round((rec.confidence || rec.expected_improvement || 0.7) * 100),\n        icon: rec.icon || getIconForParameter(rec.parameter)\n      })) : [];\n\n      // Calculate uptime from stats\n      let uptime = 98.5;\n      if (statsData.uptime) {\n        // Parse uptime string like \"0:15:32.123456\"\n        const parts = statsData.uptime.split(':');\n        if (parts.length >= 2) {\n          const hours = parseFloat(parts[0]);\n          const minutes = parseFloat(parts[1]);\n          uptime = Math.min(99.9, 95 + (hours * 60 + minutes) / 60);\n        }\n      }\n      const dashboardData = {\n        kpiData: {\n          qualityRate: qualityData.quality_rate || dtState.quality_score * 100 || 0,\n          defectCount: qualityData.defect_count || trendsData.total_defects || 0,\n          unitsProduced: qualityData.total_units || 0,\n          uptime: uptime\n        },\n        defectDistribution,\n        performanceData,\n        realTimeMetrics,\n        aiRecommendations\n      };\n      setData(dashboardData);\n      setLoading(false);\n      setError(null);\n    } catch (err) {\n      console.error('Error fetching dashboard data:', err);\n      setError('Failed to load dashboard data');\n      setLoading(false);\n    }\n  }, [API_BASE_URL]);\n\n  // Helper function to get icon for parameter\n  const getIconForParameter = param => {\n    const iconMap = {\n      'furnace_temperature': 'LocalFireDepartment',\n      'belt_speed': 'Speed',\n      'mold_temp': 'Thermostat',\n      'forming_pressure': 'Compress',\n      'cooling_rate': 'AcUnit',\n      'energy_consumption': 'ElectricBolt'\n    };\n    return iconMap[param] || 'Psychology';\n  };\n  useEffect(() => {\n    // Initial fetch\n    fetchData();\n\n    // Set up polling for periodic updates (every 10 minutes = 600000 ms)\n    const interval = setInterval(fetchData, 600000);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [fetchData]);\n  return {\n    data,\n    loading,\n    error\n  };\n};\n_s(useDashboardData, \"tGFAWcmjCA/uBEYDKnammMTsm/g=\");\nexport default useDashboardData;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","DEFECT_COLORS","crack","bubble","chip","stain","cloudiness","deformation","DEFECT_NAMES","useDashboardData","_s","data","setData","loading","setLoading","error","setError","fetchCountRef","performanceHistoryRef","API_BASE_URL","process","env","REACT_APP_API_URL","fetchData","_sensorParams$furnace","_sensorParams$furnace2","_sensorParams$forming","_sensorParams$forming2","current","isFirstFetch","qualityRes","alertsRes","trendsRes","efficiencyRes","rlRecsRes","statsRes","dtStateRes","Promise","allSettled","fetch","qualityData","status","value","ok","json","statsData","dtState","dtResponse","trendsData","data_points","efficiencyData","recommendationsData","rlData","recommendations","length","fallbackRes","e","console","warn","defectDistribution","defectTypes","aggregated","forEach","dt","dp","push","name","color","performanceData","map","ts","Date","timestamp","time","toLocaleTimeString","hour","minute","quality","quality_rate","defects","defect_count","Math","round","slice","total_defects","sensorParams","parameters","sensor_values","realTimeMetrics","furnace_temperature","furnace","temperature","unit","max","trend","icon","furnace_pressure","pressure","belt_speed","forming","speed","mold_temp","aiRecommendations","Array","isArray","rec","text","description","action","priority","urgency","toLowerCase","impact","confidence","expected_improvement","getIconForParameter","parameter","uptime","parts","split","hours","parseFloat","minutes","min","dashboardData","kpiData","qualityRate","quality_score","defectCount","unitsProduced","total_units","err","param","iconMap","interval","setInterval","clearInterval"],"sources":["C:/Users/hehehe/Desktop/scripts/glass_ai/frontend/src/hooks/useDashboardData.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\r\n\r\ninterface KPIData {\r\n  qualityRate: number;\r\n  defectCount: number;\r\n  unitsProduced: number;\r\n  uptime: number;\r\n}\r\n\r\ninterface DefectDistribution {\r\n  name: string;\r\n  value: number;\r\n  color: string;\r\n}\r\n\r\ninterface PerformanceDataPoint {\r\n  time: string;\r\n  quality: number;\r\n  defects: number;\r\n}\r\n\r\ninterface RealTimeMetric {\r\n  name: string;\r\n  value: number;\r\n  unit: string;\r\n  max: number;\r\n  trend: 'up' | 'down' | 'stable';\r\n  icon: string;\r\n}\r\n\r\ninterface AIRecommendation {\r\n  text: string;\r\n  priority: 'high' | 'medium' | 'low';\r\n  impact: number;\r\n  icon: string;\r\n}\r\n\r\nexport interface DashboardData {\r\n  kpiData: KPIData;\r\n  defectDistribution: DefectDistribution[];\r\n  performanceData: PerformanceDataPoint[];\r\n  realTimeMetrics: RealTimeMetric[];\r\n  aiRecommendations: AIRecommendation[];\r\n}\r\n\r\nconst DEFECT_COLORS: Record<string, string> = {\r\n  crack: '#FF1744',\r\n  bubble: '#FFD700',\r\n  chip: '#00E676',\r\n  stain: '#9D4EDD',\r\n  cloudiness: '#00E5FF',\r\n  deformation: '#FF3366'\r\n};\r\n\r\nconst DEFECT_NAMES: Record<string, string> = {\r\n  crack: 'Трещины',\r\n  bubble: 'Пузыри',\r\n  chip: 'Сколы',\r\n  stain: 'Пятна',\r\n  cloudiness: 'Помутнение',\r\n  deformation: 'Деформация'\r\n};\r\n\r\nconst useDashboardData = () => {\r\n  const [data, setData] = useState<DashboardData | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const fetchCountRef = useRef(0);\r\n  const performanceHistoryRef = useRef<PerformanceDataPoint[]>([]);\r\n\r\n  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\r\n\r\n  // Fetch all dashboard data from backend APIs\r\n  const fetchData = useCallback(async () => {\r\n    try {\r\n      fetchCountRef.current += 1;\r\n      const isFirstFetch = fetchCountRef.current === 1;\r\n      if (isFirstFetch) setLoading(true);\r\n      \r\n      // Parallel fetch all endpoints\r\n      const [qualityRes, alertsRes, trendsRes, efficiencyRes, rlRecsRes, statsRes, dtStateRes] = await Promise.allSettled([\r\n        fetch(`${API_BASE_URL}/api/quality/metrics`),\r\n        fetch(`${API_BASE_URL}/api/alerts/active`),\r\n        fetch(`${API_BASE_URL}/api/analytics/defect-trends?timerange=24h&grouping=hourly`),\r\n        fetch(`${API_BASE_URL}/api/analytics/production-efficiency?timerange=24h`),\r\n        fetch(`${API_BASE_URL}/api/rl/recommendations/detailed`),\r\n        fetch(`${API_BASE_URL}/api/statistics`),\r\n        fetch(`${API_BASE_URL}/api/digital-twin/state`)\r\n      ]);\r\n\r\n      // Parse quality metrics\r\n      let qualityData: any = {};\r\n      if (qualityRes.status === 'fulfilled' && qualityRes.value.ok) {\r\n        qualityData = await qualityRes.value.json();\r\n      }\r\n\r\n      // Parse statistics for uptime\r\n      let statsData: any = {};\r\n      if (statsRes.status === 'fulfilled' && statsRes.value.ok) {\r\n        statsData = await statsRes.value.json();\r\n      }\r\n\r\n      // Parse digital twin state for real-time sensor values\r\n      let dtState: any = {};\r\n      if (dtStateRes.status === 'fulfilled' && dtStateRes.value.ok) {\r\n        const dtResponse = await dtStateRes.value.json();\r\n        dtState = dtResponse.data || dtResponse;\r\n      }\r\n\r\n      // Parse defect trends for distribution\r\n      let trendsData: any = { data_points: [] };\r\n      if (trendsRes.status === 'fulfilled' && trendsRes.value.ok) {\r\n        trendsData = await trendsRes.value.json();\r\n      }\r\n\r\n      // Parse efficiency data for performance chart\r\n      let efficiencyData: any = { data_points: [] };\r\n      if (efficiencyRes.status === 'fulfilled' && efficiencyRes.value.ok) {\r\n        efficiencyData = await efficiencyRes.value.json();\r\n      }\r\n\r\n      // Parse RL recommendations\r\n      let recommendationsData: any[] = [];\r\n      if (rlRecsRes.status === 'fulfilled' && rlRecsRes.value.ok) {\r\n        const rlData = await rlRecsRes.value.json();\r\n        recommendationsData = rlData.recommendations || rlData || [];\r\n      }\r\n      \r\n      // Fallback to regular recommendations\r\n      if (!recommendationsData || recommendationsData.length === 0) {\r\n        try {\r\n          const fallbackRes = await fetch(`${API_BASE_URL}/api/recommendations`);\r\n          if (fallbackRes.ok) {\r\n            recommendationsData = await fallbackRes.json();\r\n          }\r\n        } catch (e) {\r\n          console.warn('Fallback recommendations failed:', e);\r\n        }\r\n      }\r\n\r\n      // Build defect distribution from trends data\r\n      const defectDistribution: DefectDistribution[] = [];\r\n      const defectTypes = ['crack', 'bubble', 'chip', 'stain', 'cloudiness', 'deformation'];\r\n      \r\n      if (trendsData.data_points && trendsData.data_points.length > 0) {\r\n        // Aggregate defects from all data points\r\n        const aggregated: Record<string, number> = {};\r\n        defectTypes.forEach(dt => aggregated[dt] = 0);\r\n        \r\n        trendsData.data_points.forEach((dp: any) => {\r\n          defectTypes.forEach(dt => {\r\n            aggregated[dt] += dp[dt] || 0;\r\n          });\r\n        });\r\n        \r\n        defectTypes.forEach(dt => {\r\n          if (aggregated[dt] > 0) {\r\n            defectDistribution.push({\r\n              name: DEFECT_NAMES[dt] || dt,\r\n              value: aggregated[dt],\r\n              color: DEFECT_COLORS[dt] || '#888888'\r\n            });\r\n          }\r\n        });\r\n      }\r\n      \r\n      // Fallback if no data\r\n      if (defectDistribution.length === 0) {\r\n        defectDistribution.push(\r\n          { name: 'Трещины', value: 0, color: '#FF1744' },\r\n          { name: 'Пузыри', value: 0, color: '#FFD700' },\r\n          { name: 'Сколы', value: 0, color: '#00E676' }\r\n        );\r\n      }\r\n\r\n      // Build performance data from efficiency or trends\r\n      let performanceData: PerformanceDataPoint[] = [];\r\n      \r\n      if (efficiencyData.data_points && efficiencyData.data_points.length > 0) {\r\n        performanceData = efficiencyData.data_points.map((dp: any) => {\r\n          const ts = new Date(dp.timestamp);\r\n          return {\r\n            time: ts.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' }),\r\n            quality: dp.quality_rate || dp.quality || 95,\r\n            defects: dp.defect_count || Math.round((100 - (dp.quality_rate || 95)) * 10)\r\n          };\r\n        }).slice(-12); // Last 12 points\r\n      } else if (trendsData.data_points && trendsData.data_points.length > 0) {\r\n        performanceData = trendsData.data_points.map((dp: any) => {\r\n          const ts = new Date(dp.timestamp);\r\n          return {\r\n            time: ts.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' }),\r\n            quality: 100 - (dp.total_defects || 0) * 0.5,\r\n            defects: dp.total_defects || 0\r\n          };\r\n        }).slice(-12);\r\n      }\r\n      \r\n      // Store in history and merge\r\n      if (performanceData.length > 0) {\r\n        performanceHistoryRef.current = performanceData;\r\n      } else {\r\n        performanceData = performanceHistoryRef.current;\r\n      }\r\n\r\n      // Build real-time metrics from digital twin state\r\n      const sensorParams = dtState.parameters || dtState.sensor_values || {};\r\n      const realTimeMetrics: RealTimeMetric[] = [\r\n        {\r\n          name: 'Температура печи',\r\n          value: Math.round(sensorParams.furnace_temperature || sensorParams.furnace?.temperature || 1520),\r\n          unit: '°C',\r\n          max: 1600,\r\n          trend: 'stable',\r\n          icon: 'LocalFireDepartment'\r\n        },\r\n        {\r\n          name: 'Давление печи',\r\n          value: Math.round((sensorParams.furnace_pressure || sensorParams.furnace?.pressure || 25) * 10) / 10,\r\n          unit: 'кПа',\r\n          max: 50,\r\n          trend: 'stable',\r\n          icon: 'WaterDrop'\r\n        },\r\n        {\r\n          name: 'Скорость ленты',\r\n          value: Math.round(sensorParams.belt_speed || sensorParams.forming?.speed || 155),\r\n          unit: 'м/мин',\r\n          max: 200,\r\n          trend: 'stable',\r\n          icon: 'Speed'\r\n        },\r\n        {\r\n          name: 'Температура формы',\r\n          value: Math.round(sensorParams.mold_temp || sensorParams.forming?.mold_temp || 320),\r\n          unit: '°C',\r\n          max: 400,\r\n          trend: 'stable',\r\n          icon: 'Thermostat'\r\n        }\r\n      ];\r\n\r\n      // Build AI recommendations from RL data\r\n      const aiRecommendations: AIRecommendation[] = Array.isArray(recommendationsData) && recommendationsData.length > 0\r\n        ? recommendationsData.map((rec: any) => ({\r\n            text: rec.text || rec.description || rec.action || 'Рекомендация RL агента',\r\n            priority: (rec.priority || rec.urgency || 'medium').toLowerCase() as 'high' | 'medium' | 'low',\r\n            impact: rec.impact || Math.round((rec.confidence || rec.expected_improvement || 0.7) * 100),\r\n            icon: rec.icon || getIconForParameter(rec.parameter)\r\n          }))\r\n        : [];\r\n\r\n      // Calculate uptime from stats\r\n      let uptime = 98.5;\r\n      if (statsData.uptime) {\r\n        // Parse uptime string like \"0:15:32.123456\"\r\n        const parts = statsData.uptime.split(':');\r\n        if (parts.length >= 2) {\r\n          const hours = parseFloat(parts[0]);\r\n          const minutes = parseFloat(parts[1]);\r\n          uptime = Math.min(99.9, 95 + (hours * 60 + minutes) / 60);\r\n        }\r\n      }\r\n\r\n      const dashboardData: DashboardData = {\r\n        kpiData: {\r\n          qualityRate: qualityData.quality_rate || dtState.quality_score * 100 || 0,\r\n          defectCount: qualityData.defect_count || trendsData.total_defects || 0,\r\n          unitsProduced: qualityData.total_units || 0,\r\n          uptime: uptime\r\n        },\r\n        defectDistribution,\r\n        performanceData,\r\n        realTimeMetrics,\r\n        aiRecommendations\r\n      };\r\n\r\n      setData(dashboardData);\r\n      setLoading(false);\r\n      setError(null);\r\n      \r\n    } catch (err) {\r\n      console.error('Error fetching dashboard data:', err);\r\n      setError('Failed to load dashboard data');\r\n      setLoading(false);\r\n    }\r\n  }, [API_BASE_URL]);\r\n\r\n  // Helper function to get icon for parameter\r\n  const getIconForParameter = (param: string): string => {\r\n    const iconMap: Record<string, string> = {\r\n      'furnace_temperature': 'LocalFireDepartment',\r\n      'belt_speed': 'Speed',\r\n      'mold_temp': 'Thermostat',\r\n      'forming_pressure': 'Compress',\r\n      'cooling_rate': 'AcUnit',\r\n      'energy_consumption': 'ElectricBolt'\r\n    };\r\n    return iconMap[param] || 'Psychology';\r\n  };\r\n\r\n  useEffect(() => {\r\n    // Initial fetch\r\n    fetchData();\r\n    \r\n    // Set up polling for periodic updates (every 10 minutes = 600000 ms)\r\n    const interval = setInterval(fetchData, 600000);\r\n    \r\n    return () => {\r\n      clearInterval(interval);\r\n    };\r\n  }, [fetchData]);\r\n\r\n  return { data, loading, error };\r\n};\r\n\r\nexport default useDashboardData;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}